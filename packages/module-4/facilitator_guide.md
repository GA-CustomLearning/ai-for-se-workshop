# 🧑‍🏫 Instructor Guide: Module 4 – Developer Workflow Integration Activity

## ⏱️ Duration
**30 minutes total**
- 10 min Demo
- 15 min Learner Activity
- 5 min Debrief & Share

---

## 🎯 Job To Be Done
Help engineers integrate AI tools into existing workflows for measurable productivity gains.

---

## 🗺️ Content Flow

### 👨‍🏫 Instructor Demo (10 min)
- Show how to use **Gemini CLI** to build a small client-side app for a marketing landing page.  
- Highlight:  
  - Rapid prototyping across 5–6 pages  
  - Using cloud-based agents vs local agents  
- Optional: Briefly discuss Claude Code and Codex with pros/cons.  
- Focus on **practical scenarios** and **developer pain points**.  

---

### 🛠 Learner Activity (15 min)
Guide learners to:  
1. Map their current workflows.  
2. Identify 3–5 integration points for AI tools.  
3. Create a personalized AI integration plan.  

Encourage them to:  
✅ Think about repetitive or time-consuming steps.  
✅ Match tools to pain points.  
✅ Consider team workflows and solo workflows separately.  

---

### 💬 Debrief & Group Share (5 min)
- Facilitate sharing of top integration points.  
- Prompt discussion:  
  - Cloud vs local agents: Which fits their use case?  
  - How to measure success of AI adoption?  

---

## 🛠 Tools
- [GitHub Copilot](https://github.com/features/copilot)  
- [Gemini CLI](https://ai.google/tools/gemini)  
- [Claude Code](https://www.anthropic.com/product)  

---

## 🎯 Outcomes
Participants will:  
✅ Identify 3–5 high-value AI integration points.  
✅ Draft a personalized AI adoption plan.  
✅ Understand trade-offs between AI tool types.  

---

## 📌 Key Talking Points
- Random AI use → Strategic integration = **higher ROI**  
- Consistent productivity gains reduce wasted effort.  
- Emotional safety: Developers feel empowered, not replaced.

---

## 🚀 Stretch Activity: Abstraction Layers in AI Tools

### 📌 Purpose
To explore the trade-offs between different levels of abstraction when using AI tools in software development.

### 📝 Discussion Points
- **Writing by Hand:**
  - **Pros:** Full control, deep understanding of code, no dependencies.
  - **Cons:** Slow, prone to human error, requires extensive knowledge.
- **Autocomplete:**
  - **Pros:** Speeds up coding, reduces typos, provides suggestions based on context.
  - **Cons:** Can suggest incorrect code, requires constant human review, limited to single lines/snippets.
- **Chat (e.g., ChatGPT, Claude):**
  - **Pros:** Generates larger blocks of code, explains concepts, can refactor/debug.
  - **Cons:** Can hallucinate, context window limitations, not directly integrated into IDE for real-time coding.
- **Agent Mode (e.g., Cursor, Co-pilot Agents):**
  - **Pros:** Automates multi-step tasks, understands project context, can make changes across multiple files.
  - **Cons:** Less control, can make unexpected changes, requires trust in the agent, debugging agent failures can be complex.
- **Background Agents:**
  - **Pros:** Continuous monitoring, proactive suggestions, can automate complex workflows in the background.
  - **Cons:** High complexity to set up and manage, potential for unexpected behavior, requires significant trust and oversight.

### 💬 Facilitator Notes
- Encourage participants to share their experiences with each abstraction level.
- Discuss scenarios where each level is most appropriate.
- Emphasize the importance of understanding the underlying mechanisms even when using higher-level abstractions.
- Highlight the balance between speed/automation and control/understanding.